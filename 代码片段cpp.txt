{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }


	"ROS2节点创建常规流程": {
		"prefix": "ros2_node_cpp",
		"body": [
				"// 1.包含头文件；",
				"#include \"rclcpp/rclcpp.hpp\"",
				"",
				"using std::placeholders::_1;",
				"using namespace std::chrono_literals;",
				"// 3.定义节点类；",
				"class Mynode : public rclcpp::Node",
				"{",
				"public:",
				"    Mynode()",
				"    : Node(\"Mynode\")",
				"    {",
				"    //3-1.输出日志；",
				"    RCLCPP_INFO(this->get_logger(),\"节点创建'%s'\",\"成功！\");",
				"    // 3-2.创建定时器；",
				"    timer_ = this->create_wall_timer(500ms, std::bind(&Mynode::timer_callback, this));",
				"    }",
				"",
				"private:",
				"    void timer_callback()",
				"    {",
				"    // 3-3.组织消息",
				"",
				"    }",
				"    rclcpp::TimerBase::SharedPtr timer_;",
				"};",
				"",
				"int main(int argc, char * argv[])",
				"{",
				"// 2.初始化 ROS2 客户端；",
				"rclcpp::init(argc, argv);",
				"// 4.调用spin函数,并传入节点对象指针。",
				"rclcpp::spin(std::make_shared<Mynode>());",
				"// 5.释放资源；",
				"rclcpp::shutdown();",
				"return 0;",
				"}"
		],
		"description": "ros2 node func"
	},



	
	"ROS2创建服务通讯服务端cpp": {
		"prefix": "ros2_service_service_cpp",
		"body": [
				"/*  ",
				"需求：编写服务端，接收客户端发送请求，处理数据后将结果响应回客户端。",
				"步骤：",
				"    1.包含头文件；",
				"    2.初始化 ROS2 客户端；",
				"    3.定义节点类；",
				"    3-1.创建服务端；",
				"    3-2.处理请求数据并响应结果。",
				"    4.调用spin函数，并传入节点对象指针；",
				"    5.释放资源。",
				"需要修改的变量名：",
				"    MyInterfacePkg      自定义的接口包名称",
				"    MySrvType           .srv的名称",
				"    Mynode              节点名称",
				"    globle_log_name     全局日志名",
"",
				"需要自定义的地方：",
				"    //自定义数据处理方式",
				"    void Add_callback(const MySrvType::Request::SharedPtr rqs,const MySrvType::Response::SharedPtr respon) ",
				"*/",
"",
				"// 1.包含头文件；",
				"#include \"rclcpp/rclcpp.hpp\"",
				"#include \"MyInterfacePkg/srv/MySrvType.hpp\" //改成小写",
"",
				"using std::placeholders::_1;",
				"using std::placeholders::_2;",
				"using MyInterfacePkg::srv::MySrvType;",
				"// 3.定义节点类；",
				"class Mynode : public rclcpp::Node",
				"{",
				"public:",
				"    Mynode()",
				"    : Node(\"Mynode\")",
				"    {",
				"    service_=this->create_service<MySrvType>(\"MySrvType\",std::bind(&Mynode::Add_callback,this,_1,_2));",
				"    //3-1.输出日志；",
				"    RCLCPP_INFO(this->get_logger(),\"服务端创建'%s'\",\"成功！\");",
				"    }",
"",
				"private:",
				"    void Add_callback(const MySrvType::Request::SharedPtr rqs,const MySrvType::Response::SharedPtr respon)",
				"    {",
				"    // 3-3.组织消息，rqs对应.srv文件第一部分，respon对应第二部分，通过->访问其中变量",
				"    RCLCPP_INFO(this->get_logger(),\"请求数据：(%d,%d,%d),响应结果：(sum,average)=(%d,%d)\",1,2,3,4,5);",
				"    }",
				"    rclcpp::Service<MySrvType>::SharedPtr service_;",
				"};",
"",
				"int main(int argc, char * argv[])",
				"{",
				"// 2.初始化 ROS2 客户端；",
				"rclcpp::init(argc, argv);",
				"// 4.调用spin函数,并传入节点对象指针。",
				"rclcpp::spin(std::make_shared<Mynode>());",
				"// 5.释放资源；",
				"rclcpp::shutdown();",
				"return 0;",
				"}",
		],
		"description": "create a service"
	},


	"ROS2创建服务通讯客户端cpp": {
		"prefix": "ros2_service_client_cpp",
		"body": [
				"/*  ",
				"需求：编写客户端，请求数据，并处理响应结果。",
				"步骤：",
				"    1.包含头文件；",
				"    2.初始化 ROS2 客户端；",
				"    3.定义节点类；",
				"    3-1.创建客户端；",
				"    3-2.等待服务连接；",
				"    3-3.组织请求数据并发送；",
				"    4.创建对象指针调用其功能,并处理响应；",
				"    5.释放资源。",
				"",
				"需要修改的变量名：",
				"    MyInterfacePkg      自定义的接口包名称",
				"    MySrvType           .srv的名称",
				"    Mynode              节点名称",
				"    globle_log_name     全局日志名",
"",
				"需要自定义的地方：",
				"    send_request(int32_t num1, int32_t num2){                               //请求输入需要自定义",
				"    auto response = myclient->send_request(atoi(argv[1]),atoi(argv[2]));    //请求的数据自定义",
				"*/",
				"// 1.包含头文件；",
				"#include \"rclcpp/rclcpp.hpp\"",
				"#include \"MyInterfacePkg/srv/MySrvType.hpp\"",
"",
				"using MyInterfacePkg::srv::MySrvType;",
				"using namespace std::chrono_literals;",
"",
				"// 3.定义节点类；",
				"class Mynode: public rclcpp::Node{",
				"public:",
				"    Mynode():Node(\"Mynode\"){",
				"    // 3-1.创建客户端；",
				"    client_ = this->create_client<MySrvType>(\"MySrvType\");",
				"    RCLCPP_INFO(this->get_logger(),\"客户端创建，等待连接服务端！\");",
				"    }",
				"    ",
				"",
				"    // 3-2.等待服务连接；",
				"    bool connect_server(){",
				"    while (!client_->wait_for_service(1s))",
				"    {",
				"        /* 捕捉crtl+c，避免bug */",
				"        if (!rclcpp::ok())",
				"        {",
				"        RCLCPP_INFO(rclcpp::get_logger(\"globle_log_name\"),\"强制退出！\");",
				"        return false;",
				"        }",
"",
				"        RCLCPP_INFO(this->get_logger(),\"服务连接中，请稍候...\");",
				"    }",
				"    return true;",
				"    }",
				"",
				"",
				"    // 3-3.组织请求数据并发送；",
				"    rclcpp::Client<MySrvType>::FutureAndRequestId ",
				"    send_request(int32_t num1, int32_t num2){//请求输入需要自定义",
				"    auto request = std::make_shared<MySrvType::Request>();",
				"",
				"    return client_->async_send_request(request);",
				"    }",
"",
"",
				"private:",
				"    rclcpp::Client<MySrvType>::SharedPtr client_;",
				"};",
"",
				"int main(int argc, char ** argv)",
				"{",
				"    int req_num=4;",
				"    if (argc != 3){",
				"        RCLCPP_INFO(rclcpp::get_logger(\"globle_log_name\"),\"请提交正确的请求数据数量！\");",
				"        return 1;",
				"    }",
"",
				"    // 2.初始化 ROS2 客户端；",
				"    rclcpp::init(argc,argv);",
"",
				"    // 4.创建对象指针并调用其功能；",
				"    auto myclient = std::make_shared<Mynode>();",
"",
				"    //判断是否连接上",
				"    bool flag = myclient->connect_server();",
				"    if (!flag)",
				"    {",
				"        RCLCPP_INFO(rclcpp::get_logger(\"globle_log_name\"),\"服务连接失败！\");",
				"        return 0;",
				"    }",
"",
				"    //发送请求",
				"    auto response = myclient->send_request(atoi(argv[1]),atoi(argv[2]));//请求的数据自定义",
"",
				"    // 处理响应",
				"    if (rclcpp::spin_until_future_complete(myclient,response) == rclcpp::FutureReturnCode::SUCCESS)",
				"    {",
				"        auto result = response.get(); // 保存结果到局部变量,response.get()调用一次就销毁",
				"        RCLCPP_INFO(myclient->get_logger(),\"请求正常处理\");",
				"        RCLCPP_INFO(myclient->get_logger(),\"响应结果:%d!\", result->res_type);//res_type为自己定义的srv的响应变量名,可以是多个变量名",
				"    } ",
				"    else {",
				"        RCLCPP_INFO(myclient->get_logger(),\"请求异常\");",
				"    }",
"",
				"    // 5.释放资源。",
				"    rclcpp::shutdown();",
				"    return 0;",
				"}",
"",

		],
		"description": "create a 服务通讯客户端 cpp"
	},

	"ros2动作通讯服务端cpp": {
		"prefix": "ros2_action_service_cpp",
		"body": [
				"",
				"/*  ",
				"需求：编写动作服务端实现，可以提取客户端请求提交的数据，并且处理数据，",
				"    每进行一步都计算当前运算进度并连续反馈回客户端，最后，在将最终结果返回给客户端。",
				"步骤：",
				"    1.包含头文件；",
				"    2.初始化 ROS2 客户端；",
				"    3.定义节点类；",
				"    3-1.创建动作服务端；",
				"    3-2.处理请求数据；",
				"    3-3.处理取消任务请求；",
				"    3-4.生成连续反馈。",
				"    4.调用spin函数，并传入节点对象指针；",
				"    5.释放资源。",
				"需要修改的变量名：",
				"    MyInterfacePkg      自定义的接口包名称",
				"    MyActionType        .action的名称",
				"    Mynode              自定义节点名称",
"",
				"*/",
				"// 1.包含头文件；",
				"#include \"rclcpp/rclcpp.hpp\"",
				"#include \"rclcpp_action/rclcpp_action.hpp\"",
				"#include \"MyInterfacePkg/action/MyActionType.hpp\" //MyActionType改成小写",
"",
				"using namespace std::placeholders;",
				"using MyInterfacePkg::action::MyActionType;",
				"using ServerGoalHandle_MyActionType = rclcpp_action::ServerGoalHandle<MyActionType>;",
"",
				"// 3.定义节点类；",
				"class Mynode : public rclcpp::Node",
				"{",
				"public:",
"",
				"explicit Mynode(const rclcpp::NodeOptions & options = rclcpp::NodeOptions())",
				": Node(\"Mynode\", options)",
				"{",
				"    // 3-1.创建动作服务端；",
				"    /* ",
				"    template<typename ActionT, typename NodeT>",
				"    typename Server<ActionT>::SharedPtr",
				"    create_server(",
				"    NodeT node,",
				"    const std::string & name,",
				"    typename Server<ActionT>::GoalCallback handle_goal,",
				"    typename Server<ActionT>::CancelCallback handle_cancel,",
				"    typename Server<ActionT>::AcceptedCallback handle_accepted,",
				"    const rcl_action_server_options_t & options = rcl_action_server_get_default_options(),",
				"    rclcpp::CallbackGroup::SharedPtr group = nullptr)",
				"    */",
				"    this->action_server_ = rclcpp_action::create_server<MyActionType>(",
				"    this,",
				"    \"MyActionType\",",
				"    std::bind(&Mynode::handle_goal, this, _1, _2),",
				"    std::bind(&Mynode::handle_cancel, this, _1),",
				"    std::bind(&Mynode::handle_accepted, this, _1));",
				"    RCLCPP_INFO(this->get_logger(),\"动作服务端创建，等待请求...\");",
				"}",
"",
				"private:",
"",
				"rclcpp_action::Server<MyActionType>::SharedPtr action_server_;",
"",
				"// 3-2.处理请求数据；",
				"/* ",
				"using GoalCallback = std::function<GoalResponse(",
				"const GoalUUID &, std::shared_ptr<const typename ActionT::Goal>)>;",
				"*/",
				"rclcpp_action::GoalResponse handle_goal(const rclcpp_action::GoalUUID & uuid,std::shared_ptr<const MyActionType::Goal> goal)",
				"{",
				"    (void)uuid;",
				"    //编写拒绝逻辑,客户端发送的请求数据在goal里面,goal->定义的变量名",
				"    if (true) {",
				"    RCLCPP_INFO(this->get_logger(), \"请求的目标值不符合要求\");",
				"    return rclcpp_action::GoalResponse::REJECT;",
				"    }",
				"    RCLCPP_INFO(this->get_logger(), \"接收到动作客户端请求，请求数字为\");",
				"    return rclcpp_action::GoalResponse::ACCEPT_AND_EXECUTE;",
				"}",
"",
				"// 3-3.处理取消任务请求；",
				"/* ",
				"using CancelCallback = std::function<CancelResponse(std::shared_ptr<ServerGoalHandle<ActionT>>)>;",
				"*/",
				"rclcpp_action::CancelResponse handle_cancel(const std::shared_ptr<ServerGoalHandle_MyActionType> goal_handle)",
				"{",
				"    //只要客户端取消操作，就会调用这个函数，取消进程",
				"    (void)goal_handle;",
				"    RCLCPP_INFO(this->get_logger(), \"接收到任务取消请求\");",
				"    return rclcpp_action::CancelResponse::ACCEPT;",
				"}",
"",
				"    // 3-4.生成连续反馈。",
				"/* ",
				"using AcceptedCallback = std::function<void (std::shared_ptr<ServerGoalHandle<ActionT>>)>;",
				"*/",
				"void handle_accepted(const std::shared_ptr<ServerGoalHandle_MyActionType> goal_handle)",
				"{",
				"    //新建子线程处理耗时的主逻辑实现",
				"    std::thread{std::bind(&Mynode::execute, this, _1), goal_handle}.detach();",
				"}",
				"//主逻辑实现",
				"void execute(const std::shared_ptr<ServerGoalHandle_MyActionType> goal_handle)",
				"{",
				"    //生成连续反馈的api",
				"    /*  void publish_feedback(std::shared_ptr<typename ActionT::Feedback> feedback_msg) */",
				"    //auto feedback = std::make_shared<MyActionType::Feedback>();",
				"    //goal_handle->publish_feedback(feedback);",
				"    //检测是否客户端有取消任务的操作",
				"    //goal_handle->is_canceling()",
				"    //任务取消api",
				"    /*   void canceled(typename ActionT::Result::SharedPtr result_msg) */",
				"    //auto result = std::make_shared<MyActionType::Result>();",
				"    //goal_handle->canceled(result);",
				"    //生成最终响应结果",
				"    /*   void succeed(typename ActionT::Result::SharedPtr result_msg) */",
				"    //goal_handle->succeed(result);",
"",
				"    RCLCPP_INFO(this->get_logger(), \"开始执行任务\");",
"",
				"    const auto goal = goal_handle->get_goal();//定义的action的第一部分，由客户端传入",
"",
				"    auto result = std::make_shared<MyActionType::Result>();//即定义的action第二部分",
				"    auto feedback = std::make_shared<MyActionType::Feedback>();//定义的action的第三部分",
				"    int32_t sum=0;",
"",
				"    //设置休眠，单位HZ",
				"    rclcpp::Rate loop_rate(10.0);",
"",
				"    for (int i = 1; (/* i <= 终点条件 */) && rclcpp::ok(); i++) {",
"",
				"    if (goal_handle->is_canceling()) {",
				"        /*如果任务被取消",
				"        此处需要自己编写取消时返回什么结果",
				"        例如：result->sum = sum;",
				"        */",
				"        goal_handle->canceled(result);",
				"        RCLCPP_INFO(this->get_logger(), \"任务取消\");",
				"        return;",
				"    }",
				"    ",
				"    /* 计算进度，发送反馈",
				"    需要自己编写运行过程中的进度计算，或者反馈的数据计算方式",
				"    例如：feedback->MyFeedbackType = (double_t)i / goal->num;*/",
				"    goal_handle->publish_feedback(feedback);",
				"    _Float64 progress_bar=0.0;",
				"    RCLCPP_INFO(this->get_logger(), \"连续反馈中，进度：%.2f\", progress_bar);",
				"    loop_rate.sleep();",
				"    }",
"",
				"    if (rclcpp::ok()) {",
				"    /* 循环之外，说明到达了终点，发送最终结果给客户端",
				"    此处需要自己编写到达重点应返回什么数据",
				"    例如：result->sum = sum;",
				"    */",
				"    goal_handle->succeed(result);",
				"    RCLCPP_INFO(this->get_logger(), \"任务完成！\");",
				"    }",
				"}",
"",
"",
				"}; ",
"",
				"int main(int argc, char ** argv)",
				"{",
				"// 2.初始化 ROS2 客户端；",
				"rclcpp::init(argc, argv);",
				"// 4.调用spin函数，并传入节点对象指针；",
				"auto action_server = std::make_shared<Mynode>();",
"",
				"rclcpp::spin(action_server);",
				"// 5.释放资源。",
				"rclcpp::shutdown();",
				"return 0;",
				"} ",
		],
		"description": "创建一份动作通讯服务端cpp模板"
	},

	"ros2动作通讯客户端cpp": {
		"prefix": "ros2_action_client_cpp",
		"body": [
				"/*  ",
				"需求：编写动作客户端实现，可以提交目标数据到服务端，并处理服务端的连续反馈以及最终返回结果。",
				"步骤：",
				"    1.包含头文件；",
				"    2.初始化 ROS2 客户端；",
				"    3.定义节点类；",
				"    3-1.创建动作客户端；",
				"    3-2.发送请求；",
				"    3-3.处理目标发送后的反馈；",
				"    3-4.处理连续反馈；",
				"    3-5.处理最终响应。",
				"    4.调用spin函数，并传入节点对象指针；",
				"    5.释放资源。",
				"需要修改的变量名：",
				"    MyInterfacePkg      自定义的接口包名称",
				"    MyActionType        .action的名称",
				"    Mynode              自定义节点名称",
				"*/",
				"// 1.包含头文件；",
				"#include \"rclcpp/rclcpp.hpp\"",
				"#include \"rclcpp_action/rclcpp_action.hpp\"",
				"#include \"MyInterfacePkg/action/MyActionType.hpp\"  //MyActionType改成小写",
"",
				"using MyInterfacePkg::action::MyActionType;",
				"using GoalHandleMyActionType = rclcpp_action::ClientGoalHandle<MyActionType>;",
				"using namespace std::placeholders;",
				"using namespace std::chrono_literals;",
"",
				"// 3.定义节点类；",
				"class Mynode : public rclcpp::Node",
				"{",
				"public:",
"",
				"explicit Mynode(const rclcpp::NodeOptions & node_options = rclcpp::NodeOptions())",
				": Node(\"Mynode\", node_options)",
				"{",
				"    // 3-1.创建动作客户端；",
				"    /* ",
				"    template<typename ActionT, typename NodeT>",
				"    typename Client<ActionT>::SharedPtr",
				"    create_client(",
				"    NodeT node,",
				"    const std::string & name,",
				"    rclcpp::CallbackGroup::SharedPtr group = nullptr,",
				"    const rcl_action_client_options_t & options = rcl_action_client_get_default_options())",
				"    */",
				"    this->client_ptr_ = rclcpp_action::create_client<MyActionType>(this,\"MyActionType\");",
				"}",
"",
				"// 3-2.发送请求；",
				"/* 自定义请求数据类型goal_type，即action文件第一部分，例如 int64_t*/",
				"void send_goal(goal_type num)",
				"{",
				"    //初始化",
				"    if (!this->client_ptr_) {",
				"    RCLCPP_ERROR(this->get_logger(), \"动作客户端未被初始化。\");",
				"    }",
				"    //连接服务器",
				"    if (!this->client_ptr_->wait_for_action_server(10s)) {",
				"    RCLCPP_ERROR(this->get_logger(), \"服务连接失败！\");",
				"    return;",
				"    }",
"",
				"    /*  发送具体请求 ",
				"    std::shared_future<typename GoalHandle::SharedPtr>",
				"    async_send_goal(",
				"    const typename ActionT::Goal; & goal, ",
				"    const rclcpp_action::Client<ActionT>::SendGoalOptions & options = SendGoalOptions()) */",
				"    auto goal_msg = MyActionType::Goal();",
				"    goal_msg.num = num;",
				"    RCLCPP_INFO(this->get_logger(), \"发送请求数据！\");",
"",
				"    send_goal_options_.goal_response_callback =std::bind(&ActionClient::goal_response_callback, this, _1);",
				"    send_goal_options_.feedback_callback =std::bind(&ActionClient::feedback_callback, this, _1, _2);",
				"    send_goal_options_.result_callback =std::bind(&ActionClient::result_callback, this, _1);",
"",
				"    goal_handle_future_ = this->client_ptr_->async_send_goal(goal_msg, send_goal_options_);",
				"}",
"",
				"    // 任务取消方法",
				"void cancel_goal() {",
				"    if (goal_handle_future_.valid()) {",
				"        auto goal_handle = goal_handle_future_.get();",
				"        client_ptr_->async_cancel_goal(goal_handle);  // 发送取消请求",
				"        RCLCPP_INFO(this->get_logger(), \"已发送取消请求\");",
				"    }",
				"}",
"",
				"private:",
				"rclcpp_action::Client<Progress>::SharedPtr client_ptr_;",
				"rclcpp_action::Client<Progress>::SendGoalOptions send_goal_options_;",
				"std::shared_future<GoalHandleMyActionType::SharedPtr> goal_handle_future_;",
"",
"",
				"/* 3-3.处理目标发送后的反馈；",
				"std::function<void (typename rclcpp_action::ClientGoalHandle<ActionT>::SharedPtr)>;*/",
				"void goal_response_callback(GoalHandleMyActionType::SharedPtr goal_handle)",
				"{",
				"    if (!goal_handle) {",
				"    RCLCPP_ERROR(this->get_logger(), \"目标请求被服务器拒绝！\");",
				"    } else {",
				"    RCLCPP_INFO(this->get_logger(), \"目标被接收，等待结果中\");",
				"    }",
				"}",
"",
				"/*  3-4.处理连续反馈；",
				"std::function<void (",
				"typename rclcpp_action::ClientGoalHandle<ActionT>::SharedPtr,",
				" std::shared_ptr<const typename ActionT::Feedback>)>; */",
				"void feedback_callback(GoalHandleMyActionType::SharedPtr goal_handle,const std::shared_ptr<const MyActionType::Feedback> feedback)",
				"{",
				"    (void)goal_handle;",
				"    /* ",
				"    此处需要自定义反馈日志输出，反馈数据来自于feedback->",
				"    例如：progress_bar = (int32_t)(feedback->feedback_type * 100);*/",
				"    int32_t progress_bar =10;",
				"    RCLCPP_INFO(this->get_logger(), \"当前进度: %d%%\", progress_bar);",
				"}",
"",
				"/* 3-5.处理最终响应。",
				"std::function<void (const rclcpp_action::ClientGoalHandle<ActionT>::WrappedResult & result)>; */",
				"void result_callback(const GoalHandleMyActionType::WrappedResult & result)",
				"{",
				"    //通过状态码result.code判断最终结果状态",
				"    switch (result.code) {",
				"    case rclcpp_action::ResultCode::SUCCEEDED:",
				"        break;",
				"    case rclcpp_action::ResultCode::ABORTED:",
				"        RCLCPP_ERROR(this->get_logger(), \"任务被中止\");",
				"        return;",
				"    case rclcpp_action::ResultCode::CANCELED:",
				"        RCLCPP_ERROR(this->get_logger(), \"任务被取消\");",
				"        return;",
				"    default:",
				"        RCLCPP_ERROR(this->get_logger(), \"未知异常\");",
				"        return;",
				"    }",
				"    /* 自定义日志输出",
				"    例如： RCLCPP_INFO(this->get_logger(), \"任务执行完毕，最终结果: %d\", result.result->sum);*/",
				"    RCLCPP_INFO(this->get_logger(), \"任务执行完毕，最终结果:\");",
				"}",
				"}; ",
"",
				"int main(int argc, char ** argv)",
				"{",
				"    if(argc!=2)",
				"    {",
				"        RCLCPP_ERROR(rclcpp::get_logger(\"globle_log_name\"),\"请提交一个输入数据\");",
				"        return 1;",
				"    // 2.初始化 ROS2 客户端；",
				"    rclcpp::init(argc, argv);",
"",
				"    // 4.调用spin函数，并传入节点对象指针；",
				"    auto action_client = std::make_shared<Mynode>();",
"",
				"    action_client->send_goal(atoi(argv[1]));",
				"    rclcpp::spin(action_client);",
				"    // 5.释放资源。",
				"    rclcpp::shutdown();",
				"    return 0;",
				"}",
		],
		"description": "创建一份动作通讯客户端cpp模板"
	},

	"ros2参数服务服务端cpp": {
		"prefix": "ros2_param_service_cpp",
		"body": [
				"/*",
				"    需求：编写参数服务端，设置并操作参数。",
				"    步骤：",
				"        1.包含头文件；",
				"        2.初始化 ROS2 客户端；",
				"        3.定义节点类；",
				"            3-1.声明参数；",
				"            3-2.查询参数；",
				"            3-3.修改参数；",
				"            3-4.删除参数。",
				"        4.创建节点对象指针，调用参数操作函数，并传递给spin函数；",
				"        5.释放资源。",
				"    需要修改的变量名：",
				"        Mynode              节点名称",
				"*/",
"",
				"// 1.包含头文件；",
				"#include \"rclcpp/rclcpp.hpp\"",
"",
				"// 3.定义节点类；",
				"class Mynode: public rclcpp::Node{",
				"    public:",
				"        Mynode():Node(\"Mynode_param\",",
				"        rclcpp::NodeOptions().allow_undeclared_parameters(true)){}",
"",
				"        // 3-1.声明参数；",
				"        void declare_param(){",
				"            /* 声明参数并设置默认值API",
				"            this->declare_parameter(\"key\",value)",
				"            例如:this->declare_parameter(\"car_type\",\"Tiger\"); */",
				"            /* 设置覆盖API",
				"            需要设置 rclcpp::NodeOptions().allow_undeclared_parameters(true),否则非法 ",
				"            this->set_parameter(rclcpp::Parameter(\"key\",value));*/",
				"        }",
"",
				"        // 3-2.查询参数",
				"        void get_param(){",
				"            RCLCPP_INFO(this->get_logger(),\"------------------查----------------\");",
				"            /* 查询参数API",
				"            this->get_parameter(\"key\")                      //返回rclcpp::Parameter",
				"            this->has_parameter(\"key\")                      //返回bool",
				"            this->get_parameters(vector<string> keys);      //返回vector<rclcpp::Parameter> */",
				"        }",
"",
				"        // 3-3.修改参数",
				"        void update_param(){",
				"            RCLCPP_INFO(this->get_logger(),\"------------------改----------------\");",
				"            /* API",
				"            需要设置 rclcpp::NodeOptions().allow_undeclared_parameters(true),否则非法 ",
				"            this->set_parameter(rclcpp::Parameter(\"key\",value));*/",
				"        }",
				"        // 3-4.删除参数",
				"        void del_param(){",
				"            RCLCPP_INFO(this->get_logger(),\"------------------删----------------\");",
				"            /* API",
				"            //不能删除用this->declare_parameter声明的参数，只能删除this->set_parameter声明的参数",
				"            this->undeclare_parameter(\"key\") */",
				"        }",
				"};",
"",
				"int main(int argc, char ** argv)",
				"{",
				"    // 2.初始化 ROS2 客户端；",
				"    rclcpp::init(argc,argv);",
"",
				"    // 4.创建节点对象指针，调用参数操作函数，并传递给spin函数；",
				"    auto paramServer= std::make_shared<Mynode>();",
				"    paramServer->declare_param();",
				"    paramServer->get_param();",
				"    paramServer->update_param();",
				"    paramServer->del_param();",
				"    rclcpp::spin(paramServer);",
"",
				"    // 5.释放资源。",
				"    rclcpp::shutdown();",
				"    return 0;",
				"}",

		],
		"description": "参数服务服务端cpp模板"
	},

	"ros2参数服务客户端cpp": {
		"prefix": "ros2_param_client_cpp",
		"body": [
				"/*",
				"    需求：编写参数客户端，获取或修改服务端参数。",
				"    步骤：",
				"        1.包含头文件；",
				"        2.初始化 ROS2 客户端；",
				"        3.定义节点类；",
				"            3-1.查询参数；",
				"            3-2.修改参数；",
				"        4.创建节点对象指针，调用参数操作函数；",
				"        5.释放资源。",
				"    需要修改的变量名：",
				"        Mynode              节点名称",
				"*/",
"",
				"// 1.包含头文件；",
				"#include \"rclcpp/rclcpp.hpp\"",
"",
				"using namespace std::chrono_literals;",
"",
				"// 3.定义节点类；",
				"class Mynode: public rclcpp::Node {",
				"    public:",
				"        Mynode():Node(\"Mynode\"){",
				"            //Mynode_param_server需要与被连接的服务端节点名称一致",
				"            paramClient_ = std::make_shared<rclcpp::SyncParametersClient>(this,\"Mynode_param\");",
				"        }",
"",
				"        // 等待服务连接",
				"        bool connect_server(){",
				"            while (!paramClient_->wait_for_service(1s))",
				"            {",
				"                if (!rclcpp::ok())",
				"                {",
				"                return false;",
				"                }  ",
				"                RCLCPP_INFO(this->get_logger(),\"服务未连接\");",
				"            }",
				"            return true;",
				"        }",
"",
				"        // 3-1.查询参数；",
				"        void get_param(){",
				"            RCLCPP_INFO(this->get_logger(),\"-----------参数客户端查询参数-----------\");",
				"            /* API",
				"            auto value = paramClient_->get_parameter<value_type>(\"key\")                         //用键查询，返回value",
				"            vector<value_type> values = paramClient_->get_parameters(vector<string> keys);      //用多个键查询，返回多个value",
				"            例如：double height = paramClient_->get_parameter<double>(\"height\");",
				"            auto params = paramClient_->get_parameters({\"car_type\",\"height\",\"wheels\"});*/",
"",
				"        }",
"",
				"        // 3-2.修改参数；",
				"        void update_param(){",
				"            RCLCPP_INFO(this->get_logger(),\"-----------参数客户端修改参数-----------\");",
				"            /* API",
				"            //这是服务端不存在的参数，只有服务端设置了rclcpp::NodeOptions().allow_undeclared_parameters(true)时，",
				"            // 这个参数才会被成功设置。",
				"            //传入std::vector<rclcpp::Parameter>",
				"            paramClient_->set_parameters({rclcpp::Parameter(\"key\",value),....,rclcpp::Parameter(\"key1\",value1)})",
				"            */",
				"        }",
"",
				"    private:",
				"        rclcpp::SyncParametersClient::SharedPtr paramClient_;",
				"};",
"",
				"int main(int argc, char const *argv[])",
				"{",
				"    // 2.初始化 ROS2 客户端；",
				"    rclcpp::init(argc,argv);",
"",
				"    // 4.创建节点对象指针，调用参数操作函数；",
				"    auto paramClient = std::make_shared<Mynode>();",
				"    bool flag = paramClient->connect_server();",
				"    if(!flag){",
				"        return 0;",
				"    }",
"",
				"    paramClient->get_param();",
				"    paramClient->update_param();",
				"    paramClient->get_param();",
"",
				"    // 5.释放资源。",
				"    rclcpp::shutdown();",
				"    return 0;",
				"}",
		],
		"description": "参数服务客户端cpp模板"
	},

	"ros2 录制话题数据": {
		"prefix": "ros2_bag_record_cpp",
		"body": [
				"/*",
				"需求：录制某个话题的信息",
				"流程：",
				"    1.创建录制对象",
				"    2.设置磁盘文件",
				"    3.写数据（创建速度订阅方，回调函数中执行写出操作）",
				"",
				"需要修改的变量名：",
				"    ${1:MyInterfacePkg}      自定义的接口包名称",
				"    ${2:MyMsgType}           .msg的名称",
				"    ${3:Mynode}              自定义节点名称",
				"    ${4:topic_name}          订阅的话题名称",
				"    ${5:my_bag}              录制的文件夹名称",
				"*/",
				"",
				"#include \"rclcpp/rclcpp.hpp\"",
				"#include \"rosbag2_cpp/writer.hpp\"",
				"",
				"#include \"${1:MyInterfacePkg}/msg/${2:MyMsgType}.hpp\"//MyMsgType改成小写",
				"",
				"",
				"class ${3:Mynode} : public rclcpp::Node",
				"{",
				"public:",
				"    ${3:Mynode}() : Node(\"bag_recorder_${3:Mynode}\")",
				"    {",
				"        RCLCPP_INFO(this->get_logger(), \"消息录制对象创建\");",
				"",
				"        // 1.创建录制对象",
				"        writer_ = std::make_unique<rosbag2_cpp::Writer>();",
				"",
				"        // 2.设置磁盘文件",
				"        writer_->open(\"${5:my_bag}\"); // 相对路径，工作空间的直接子集",
				"",
				"        // 3.写数据（创建速度订阅方，回调函数中执行写出操作）",
				"        // writer_->write()",
				"        sub_ = this->create_subscription<${1:MyInterfacePkg}::msg::${2:MyMsgType}>(",
				"            \"${4:topic_name}\", 10,",
				"            std::bind(&${3:Mynode}::do_write_msg, this, std::placeholders::_1));",
				"    }",
				"",
				"private:",
				"    std::unique_ptr<rosbag2_cpp::Writer> writer_;",
				"    rclcpp::Subscription<${1:MyInterfacePkg}::msg::${2:MyMsgType}>::SharedPtr sub_;",
				"",
				"    void do_write_msg(std::shared_ptr<rclcpp::SerializedMessage> msg)",
				"    {",
				"        RCLCPP_INFO(this->get_logger(), \"数据写出...\");",
				"        writer_->write(msg, \"${4:topic_name}\", \"${1:MyInterfacePkg}/msg/${2:MyMsgType}\", this->now());",
				"        // std::shared_ptr<rclcpp::SerializedMessage> message, // 被写出的消息",
				"        // const std::string & topic_name,                     // 话题名称",
				"        // const std::string & type_name,                      // 消息类型",
				"        // const rclcpp::Time & time);                         // 时间戳",
				"    }",
				"};",
				"",
				"int main(int argc, char const *argv[])",
				"{",
				"    rclcpp::init(argc, argv);",
				"    rclcpp::spin(std::make_shared<${3:Mynode}>());",
				"    rclcpp::shutdown();",
				"",
				"    return 0;",
				"}"
		],
		"description": "录制话题数据代码模板"
	},

	"ros2 读取回放录制的话题数据": {
		"prefix": "ros2_bag_read_cpp",
		"body": [
				"/*",
				"需求：读取bag文件数据，并将数据输出至终端",
				"流程：",
				"    1.创建一个回放对象",
				"    2.设置被读取的文件",
				"    3.读消息",
				"    4.关闭文件，释放资源",
				"",
				"需要修改的变量名：",
				"    ${1:MyInterfacePkg}      自定义的接口包名称",
				"    ${2:MyMsgType}           .msg的名称",
				"    ${3:Mynode}              自定义节点名称",
				"    ${4:my_bag}              录制的文件夹名称",
				"*/",
				"",
				"#include \"rclcpp/rclcpp.hpp\"",
				"#include \"rosbag2_cpp/reader.hpp\"",
				"",
				"#include \"${1:MyInterfacePkg}/msg/${2:MyMsgType}.hpp\"",
				"",
				"class ${3:Mynode} : public rclcpp::Node",
				"{",
				"public:",
				"    ${3:Mynode}() : Node(\"bag_play_${3:Mynode}\")",
				"    {",
				"        RCLCPP_INFO(this->get_logger(), \"消息回放对象创建\");",
				"",
				"        // 1.创建回放对象",
				"        reader_ = std::make_unique<rosbag2_cpp::Reader>();",
				"",
				"        // 2.设置被读取的文件",
				"        reader_->open(\"${4:my_bag}\");",
				"",
				"        // 3.读消息",
				"        while (reader_->has_next())",
				"        {",
				"            auto ${2:MyMsgType} = reader_->read_next<${1:MyInterfacePkg}::msg::${2:MyMsgType}>();",
				"            RCLCPP_INFO(this->get_logger(), \"线速度:%.2f, 角速度:%.2f\", ${2:MyMsgType}.linear.x, ${2:MyMsgType}.angular.z);",
				"            // 修改输出格式以匹配您的消息类型",
				"        }",
				"",
				"        // 4.关闭文件",
				"        reader_->close();",
				"    }",
				"",
				"private:",
				"    std::unique_ptr<rosbag2_cpp::Reader> reader_;",
				"};",
				"",
				"int main(int argc, char const *argv[])",
				"{",
				"    rclcpp::init(argc, argv);",
				"    std::make_shared<${3:Mynode}>();",
				"    rclcpp::shutdown();",
				"",
				"    return 0;",
				"}"
		],
		"description": "回放话题数据代码模板"
	},


	"ros2静态广播器cpp": {
		"prefix": "ros2_static_tf_broadcaster_cpp",
		"body": [
			"/*",
			"需求：编写静态坐标变换程序，执行时传入两个坐标系的相对位姿关系以及父子级坐标系id，",
			"     程序运行发布静态坐标变换",
			"     ros2 run 包 可执行程序名 x y z roll pitch yaw frame child_frame",
			"流程：",
			"    0.判断传入的参数是否合法",
			"    1.创建广播对象",
			"    2.组织并发布数据",
			"",
			"需要更改的参数名：",
			"    ${1:Mynode}              节点名称",
			"*/",
			"",
			"#include <rclcpp/rclcpp.hpp>",
			"#include <tf2/LinearMath/Quaternion.h>",
			"#include <tf2_ros/static_transform_broadcaster.h>",
			"#include <geometry_msgs/msg/transform_stamped.hpp>",
			"",
			"class ${1} : public rclcpp::Node",
			"{",
			"public:",
			"    ${1}(char const *argv[]) : Node(\"${2:tf_static_broadcaster_node}\")",
			"    {",
			"        // 1.创建广播对象",
			"        broadcaster_ = std::make_shared<tf2_ros::StaticTransformBroadcaster>(this);",
			"        // 2.组织并发布数据",
			"        pub_static_tf(argv);",
			"    }",
			"",
			"private:",
			"    std::shared_ptr<tf2_ros::StaticTransformBroadcaster> broadcaster_;",
			"    void pub_static_tf(char const *argv[])",
			"    {",
			"        // 2-1.组织消息",
			"        geometry_msgs::msg::TransformStamped transform;",
			"        transform.header.stamp = this->now(); // 时间戳",
			"        transform.header.frame_id = argv[7];  // 父级坐标系",
			"        transform.child_frame_id = argv[8];   // 子级坐标系",
			"        // 设置偏移量",
			"        transform.transform.translation.x = atof(argv[1]);",
			"        transform.transform.translation.y = atof(argv[2]);",
			"        transform.transform.translation.z = atof(argv[3]);",
			"        // 设置四元数",
			"        // 将欧拉角转换成四元数",
			"        tf2::Quaternion qtn;",
			"        qtn.setRPY(atof(argv[4]), atof(argv[5]), atof(argv[6]));",
			"        transform.transform.rotation.x = qtn.x();",
			"        transform.transform.rotation.y = qtn.y();",
			"        transform.transform.rotation.z = qtn.z();",
			"        transform.transform.rotation.w = qtn.w();",
			"",
			"        // 2-2.发布消息",
			"        broadcaster_->sendTransform(transform);",
			"    }",
			"};",
			"",
			"int main(int argc, char const *argv[])",
			"{",
			"    if (argc != 9)",
			"    {",
			"        RCLCPP_ERROR(rclcpp::get_logger(\"rclcpp\"), \"传入的参数不合法\");",
			"        return 1;",
			"    }",
			"    rclcpp::init(argc, argv);",
			"    rclcpp::spin(std::make_shared<${1}>(argv));",
			"    rclcpp::shutdown();",
			"    return 0;",
			"}"
		],
		"description": "静态广播器cpp模板"
	},


	"ros2动态广播器cpp": {
		"prefix": "ros2_dynamic_tf_broadcaster_cpp",
		"body": [
			"/*",
			"需求：启动 turtlesim_node 节点，编写程序，发布乌龟(turtle1)相对于窗体(world)的位姿",
			"流程：",
			"    1.创建动态广播器",
			"    2.创建订阅方",
			"    3.回调函数中获取乌龟位姿，成相对关系，并发布",
			"",
			"需要更改的参数名：",
			"    ${1:Mynode}              节点名称",
			"*/",
			"",
			"#include <rclcpp/rclcpp.hpp>",
			"#include <tf2_ros/transform_broadcaster.h>",
			"#include <tf2/LinearMath/Quaternion.h>",
			"#include <geometry_msgs/msg/transform_stamped.hpp>",
			"",
			"#include <turtlesim/msg/pose.hpp>",
			"",
			"class ${1} : public rclcpp::Node",
			"{",
			"public:",
			"    ${1}() : Node(\"${2:tf_dyna_broadcaster_node}\")",
			"    {",
			"        // 1.创建动态广播器",
			"        brocaster_ = std::make_shared<tf2_ros::TransformBroadcaster>(this);",
			"",
			"        // 2.创建乌龟位姿订阅方",
			"        pose_sub_ = this->create_subscription<turtlesim::msg::Pose>(",
			"            \"/turtle1/pose\", 10, std::bind(&${1}::do_pose, this, std::placeholders::_1));",
			"    }",
			"",
			"private:",
			"    void do_pose(const turtlesim::msg::Pose &pose)",
			"    {",
			"        // 3.回调函数中获取乌龟位姿，成相对关系，并发布",
			"        // 3-1.组织消息",
			"        geometry_msgs::msg::TransformStamped ts;",
			"        ts.header.stamp = this->now();",
			"        ts.header.frame_id = \"world\";",
			"        ts.child_frame_id = \"turtle1\";",
			"        ts.transform.translation.x = pose.x;",
			"        ts.transform.translation.y = pose.y;",
			"        ts.transform.translation.z = 0.0;",
			"        tf2::Quaternion qtn; // 从欧拉角转换出四元数",
			"        qtn.setRPY(0, 0, pose.theta);",
			"        ts.transform.rotation.x = qtn.x();",
			"        ts.transform.rotation.y = qtn.y();",
			"        ts.transform.rotation.z = qtn.z();",
			"        ts.transform.rotation.w = qtn.w();",
			"",
			"        // 3-2.发布",
			"        brocaster_->sendTransform(ts);",
			"    }",
			"    std::shared_ptr<tf2_ros::TransformBroadcaster> brocaster_;",
			"    rclcpp::Subscription<turtlesim::msg::Pose>::SharedPtr pose_sub_;",
			"};",
			"",
			"int main(int argc, char const *argv[])",
			"{",
			"    rclcpp::init(argc, argv);",
			"    rclcpp::spin(std::make_shared<${1}>());",
			"    rclcpp::shutdown();",
			"",
			"    return 0;",
			"}"
		],
		"description": "动态广播器cpp模板"
	},

	"ROS2有坐标的点与多个坐标系之间的坐标转换": {
		"prefix": "ros2_pointstamp_tfs_cpp",
		"body": [
				"/*",
				"  需求：将雷达感知到的障碍物的坐标点数据（相对于 laser 坐标系），",
				"       转换成相对于底盘坐标系（base_link）的坐标点。",
				"",
				"  步骤：",
				"    1.包含头文件；",
				"    2.初始化 ROS 客户端；",
				"    3.定义节点类；",
				"      3-1.创建tf缓存对象指针；",
				"      3-2.创建tf监听器；",
				"      3-3.创建坐标点订阅方并订阅指定话题；",
				"      3-4.创建消息过滤器过滤被处理的数据；",
				"      3-5.为消息过滤器注册转换坐标点数据的回调函数。",
				"    4.调用 spin 函数，并传入对象指针；",
				"    5.释放资源。",
				"*/",
				"// 1.包含头文件；",
				"#include <geometry_msgs/msg/point_stamped.hpp>",
				"#include <message_filters/subscriber.h>",
				"",
				"#include <rclcpp/rclcpp.hpp>",
				"#include <tf2_ros/buffer.h>",
				"#include <tf2_ros/create_timer_ros.h>",
				"#include <tf2_ros/message_filter.h>",
				"#include <tf2_ros/transform_listener.h>",
				"",
				"#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>",
				"",
				"using namespace std::chrono_literals;",
				"",
				"// 3.定义节点类；",
				"class MessageFilterPointListener : public rclcpp::Node",
				"{",
				"public:",
				"  MessageFilterPointListener(): Node(\"message_filter_point_listener\")",
				"  {",
				"",
				"    target_frame_ = \"base_link\";",
				"",
				"    typedef std::chrono::duration<int> seconds_type;",
				"    seconds_type buffer_timeout(1);",
				"    // 3-1.创建tf缓存对象指针；",
				"    tf2_buffer_ = std::make_shared<tf2_ros::Buffer>(this->get_clock());",
				"    auto timer_interface = std::make_shared<tf2_ros::CreateTimerROS>(",
				"      this->get_node_base_interface(),",
				"      this->get_node_timers_interface());",
				"    tf2_buffer_->setCreateTimerInterface(timer_interface);",
				"    // 3-2.创建tf监听器；",
				"    tf2_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf2_buffer_);",
				"",
				"    // 3-3.创建坐标点订阅方并订阅指定话题；",
				"    point_sub_.subscribe(this, \"point\");",
				"    // 3-4.创建消息过滤器过滤被处理的数据；",
				"    /*  ",
				"    F & f,                                    订阅的对象",
				"    BufferT & buffer,                         坐标监听缓存",
				"    const std::string & target_frame,         目标坐标系（base_link）",
				"    uint32_t queue_size,                      缓冲队列长度",
				"    const rclcpp::node_interfaces::NodeLoggingInterface::SharedPtr & node_logging, ",
				"    const rclcpp::node_interfaces::NodeClockInterface::SharedPtr & node_clock,",
				"    std::chrono::duration<TimeRepT, TimeT> buffer_timeout =std::chrono::duration<TimeRepT, TimeT>::max()) 超时时间*/",
				"    tf2_filter_ = std::make_shared<tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped>>(",
				"      point_sub_, ",
				"      *tf2_buffer_, ",
				"      target_frame_, ",
				"      100, ",
				"      this->get_node_logging_interface(),",
				"      this->get_node_clock_interface(), ",
				"      buffer_timeout);",
				"    // 3-5.为消息过滤器注册转换坐标点数据的回调函数。",
				"    tf2_filter_->registerCallback(&MessageFilterPointListener::msgCallback, this);",
				"  }",
				"",
				"private:",
				"  void msgCallback(const geometry_msgs::msg::PointStamped::SharedPtr point_ptr)",
				"  {",
				"    geometry_msgs::msg::PointStamped point_out;",
				"    try {",
				"      tf2_buffer_->transform(*point_ptr, point_out, target_frame_);",
				"      RCLCPP_INFO(",
				"        this->get_logger(), \"坐标点相对于base_link的坐标:(%.2f,%.2f,%.2f)\",",
				"        point_out.point.x,",
				"        point_out.point.y,",
				"        point_out.point.z);",
				"    } catch (tf2::TransformException & ex) {",
				"      RCLCPP_WARN(",
				"        // Print exception which was caught",
				"        this->get_logger(), \"Failure %s\\n\", ex.what());",
				"    }",
				"  }",
				"  std::string target_frame_;",
				"  std::shared_ptr<tf2_ros::Buffer> tf2_buffer_;",
				"  std::shared_ptr<tf2_ros::TransformListener> tf2_listener_;",
				"  message_filters::Subscriber<geometry_msgs::msg::PointStamped> point_sub_;",
				"  std::shared_ptr<tf2_ros::MessageFilter<geometry_msgs::msg::PointStamped>> tf2_filter_;",
				"};",
				"",
				"int main(int argc, char * argv[])",
				"{",
				"  // 2.初始化 ROS 客户端；",
				"  rclcpp::init(argc, argv);",
				"  // 4.调用 spin 函数，并传入对象指针；",
				"  rclcpp::spin(std::make_shared<MessageFilterPointListener>());",
				"  // 5.释放资源。",
				"  rclcpp::shutdown();",
				"  return 0;",
				"}"
		],
		"description": "有参考坐标系的移动点与多个tf坐标系之间的坐标转换"
	},

	"ros2坐标系间变换": {
		"prefix": "ros2_coord_sys_transform_cpp",
		"body": [
				"/*  ",
				"  需求：订阅 laser 到 base_link 以及 camera 到 base_link 的坐标系关系，",
				"       并生成 laser 到 camera 的坐标变换。",
				"  步骤：",
				"    1.包含头文件；",
				"    2.初始化 ROS 客户端；",
				"    3.定义节点类；",
				"      3-1.创建tf缓存对象指针；",
				"      3-2.创建tf监听器；",
				"      3-3.按照条件查找符合条件的坐标系并生成变换后的坐标帧。",
				"    4.调用 spin 函数，并传入对象指针；",
				"    5.释放资源。",
				"*/",
				"#include \"rclcpp/rclcpp.hpp\"",
				"#include \"tf2_ros/transform_listener.h\"",
				"#include \"tf2_ros/buffer.h\"",
				"#include \"tf2/LinearMath/Quaternion.h\"",
				"",
				"using namespace std::chrono_literals;",
				"",
				"// 3.定义节点类；",
				"class MinimalFrameListener : public rclcpp::Node {",
				"public:",
				"  MinimalFrameListener():Node(\"minimal_frame_listener\"){",
				"    tf_buffer_ = std::make_unique<tf2_ros::Buffer>(this->get_clock());",
				"    transform_listener_ = std::make_shared<tf2_ros::TransformListener>(*tf_buffer_);",
				"    timer_ = this->create_wall_timer(1s, std::bind(&MinimalFrameListener::on_timer,this));",
				"  }",
				"",
				"private:",
				"  void on_timer(){",
				"    //try-catch可以用if(tf_buffer_->canTransform(\"camera\",\"laser\",tf2::TimePointZero));代替",
				"    try",
				"    { ",
				"    // geometry_msgs::msg::TransformStamped  ",
				"    // lookupTransform(const std::string & target_frame,  新父坐标系",
				"    // const std::string & source_frame,                  新子坐标系",
				"    // const TimePoint & time) const override;            转换的时间点，tf2::TimePointZero，意为最新时刻",
				"      auto transformStamped = tf_buffer_->lookupTransform(\"camera\",\"laser\",tf2::TimePointZero);",
				"      RCLCPP_INFO(this->get_logger(),\"----------------------转换结果----------------------\");",
				"      RCLCPP_INFO(this->get_logger(),\"frame_id:%s\",transformStamped.header.frame_id.c_str());",
				"      RCLCPP_INFO(this->get_logger(),\"child_frame_id:%s\",transformStamped.child_frame_id.c_str());",
				"      RCLCPP_INFO(this->get_logger(),\"坐标:(%.2f,%.2f,%.2f)\",",
				"                transformStamped.transform.translation.x,",
				"                transformStamped.transform.translation.y,",
				"                transformStamped.transform.translation.z);",
				"",
				"    }",
				"    catch(const tf2::LookupException& e)",
				"    {",
				"      RCLCPP_INFO(this->get_logger(),\"坐标变换异常：%s\",e.what());",
				"    }",
				"  }",
				"  rclcpp::TimerBase::SharedPtr timer_;",
				"  std::shared_ptr<tf2_ros::TransformListener> transform_listener_;",
				"  std::unique_ptr<tf2_ros::Buffer> tf_buffer_;",
				"};",
				"",
				"int main(int argc, char const *argv[])",
				"{",
				"  // 2.初始化 ROS 客户端；",
				"  rclcpp::init(argc,argv);",
				"  // 4.调用 spin 函数，并传入对象指针；",
				"  rclcpp::spin(std::make_shared<MinimalFrameListener>());",
				"  // 5.释放资源。",
				"  rclcpp::shutdown();",
				"  return 0;",
				"}"
		],
		"description": "ros2坐标系间的相对位置变换"
	},

	"ros2 有参考坐标系的可动点的信息发布": {
		"prefix": "ros2_pointstamp_pub_cpp",
		"body": [
"/*  ",
      "    需求：发布雷达坐标系中某个坐标点相对于雷达（laser）坐标系的位姿。",
      "    步骤：",
      "        1.包含头文件；",
      "        2.初始化 ROS 客户端；",
      "        3.定义节点类；",
      "            3-1.创建坐标点发布方；",
      "            3-2.创建定时器；",
      "            3-3.组织并发布坐标点消息。",
      "        4.调用 spin 函数，并传入对象指针；",
      "        5.释放资源。",
      "*/",
      "// 1.包含头文件；",
      "#include \"rclcpp/rclcpp.hpp\"",
      "#include \"geometry_msgs/msg/point_stamped.hpp\"",
      "",
      "using namespace std::chrono_literals;",
      "",
      "// 3.定义节点类；",
      "class MinimalPointPublisher: public rclcpp::Node {",
      "public:",
      "    MinimalPointPublisher(): Node(\"minimal_point_publisher\"),x(0.1){",
      "        // 3-1.创建坐标点发布方；",
      "        point_pub_ = this->create_publisher<geometry_msgs/msg/PointStamped>(\"point\",10);",
      "        // 3-2.创建定时器；",
      "        timer_ = this->create_wall_timer(0.1s,std::bind(&MinimalPointPublisher::on_timer, this));",
      "    }",
      "private:",
      "    void on_timer(){",
      "        // 3-3.组织并发布坐标点消息。",
      "        geometry_msgs::msg::PointStamped point;",
      "        point.header.frame_id = \"laser\";",
      "        point.header.stamp = this->now();",
      "        x += 0.004;",
      "        point.point.x = x;",
      "        point.point.y = 0.0;",
      "        point.point.z = 0.1;        ",
      "        point_pub_->publish(point);",
      "    }",
      "    rclcpp::Publisher<geometry_msgs::msg::PointStamped>::SharedPtr point_pub_;",
      "    rclcpp::TimerBase::SharedPtr timer_;",
      "    double_t x;",
      "};",
      "",
      "int main(int argc, char const *argv[])",
      "{",
      "    // 2.初始化 ROS 客户端；",
      "    rclcpp::init(argc,argv);",
      "    // 4.调用 spin 函数，并传入对象指针；",
      "    rclcpp::spin(std::make_shared<MinimalPointPublisher>());",
      "    // 5.释放资源。",
      "    rclcpp::shutdown();",
      "    return 0;",
      "}"
		],
		"description": "有参考坐标系的可动点的信息发布，可以被tf接受到"
	}

	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
}
{
	// Place your snippets for python here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	"ros2创建节点py文件": {
		"prefix": "ros2_node_py",
		"body": [
				"# 1.导包；",
				"import rclpy",
				"from rclpy.node import Node",
"",

				"# 3.定义节点类；",
				"class MyNode(Node):",
"",
				"    def __init__(self):",
				"        super().__init__('node name')",
				"        self.get_logger().info(\"节点创建了！\")",
"",
				"        # 3-2.创建定时器；",
				"        timer_period = 0.5 ",
				"        self.timer = self.create_timer(timer_period, self.timer_callback)",
"",
				"    # 3-3.组织消息并发布。",
				"    def timer_callback(self):",
				"        self.get_logger().info('回调处理的消息: \"%s\"' % \"msg data\")",

"",
"",
				"def main(args=None):",
				"    # 2.初始化 ROS2 客户端；",
				"    rclpy.init(args=args)",
				"    # 4.调用spin函数,并传入节点对象;",
				"    my_node = MyNode()",
				"    rclpy.spin(my_node)",
				"    # 5.释放资源。",
				"    rclpy.shutdown()",
"",
"",
				"if __name__ == '__main__':",
				"    main()"
		],
		"description": "创建节点代码模板"
	},

	"ros2创建服务通讯客户端py": {
		"prefix": "ros2_service_client_py",
		"body": [
				"\"\"\"",
				"    需求：编写客户端，发送两个整型变量作为请求数据，并处理响应结果。",
				"    步骤：",
				"        1.导包；",
				"        2.初始化 ROS2 客户端；",
				"        3.定义节点类；",
				"            3-1.创建客户端；",
				"            3-2.等待服务连接；",
				"            3-3.组织请求数据并发送；",
				"        4.创建对象调用其功能，处理响应结果；",
				"        5.释放资源。",
"",
				"需要修改的变量名：",
				"    MyInterfacePkg      自定义的接口包名称",
				"    MySrvType           .srv的名称",
				"    Mynode              节点名称",
				"    globle_log_py     全局日志名",
"",
				"需要自定义的地方：",
				"    def send_request(self):          请求输入需要自定义",
				"",
				"\"\"\"",
"",
"",
				"# 1.导包；",
				"import rclpy",
				"from rclpy.node import Node",
				"from rclpy.logging import get_logger",
				"import sys",
"",
				"from MyInterfacePkg.srv import MySrvType",
"",
				"# 3.定义节点类；",
				"class MyNode(Node):",
"",
				"    def __init__(self):",
				"        super().__init__('Client_py')",
				"        #创建客户端",
				"        self.client=self.create_client(MySrvType,\"MySrvType\")",
				"        self.get_logger().info(\"客户端启动！\")",
				"        #等待服务连接",
				"        while not self.client.wait_for_service(1.0):",
				"            self.get_logger().info(\"服务连接中.....\")",
				"        #请求数据初始化",
				"        self.request=MySrvType.Request()",
"",
"",
				"    # 3-3.组织消息并发布。",
				"    def send_request(self):",
				"        self.request.num1=int(sys.argv[1])",
				"        self.future=self.client.call_async(self.request)",
"",
"",
				"def main(args=None):",
				"    #校验输入",
				"    if len(sys.argv)!=4:",
				"        get_logger(\"globle_log_py\").info(\"请提交正确数量的输入！\")",
				"        return",
				"    ",
				"    # 2.初始化 ROS2 客户端；",
				"    rclpy.init(args=args)",
"",
"",
				"    # 4.调用对象，发送请求;",
				"    my_node = MyNode()",
				"    my_node.send_request()",
"",
"",
				"    #处理响应",
				"    rclpy.spin_until_future_complete(my_node,my_node.future)",
"",
				"    #通过异常捕获确定是否返回处理结果",
				"    try:",
				"        response=my_node.future.result()",
				"    except Exception as e:",
				"        my_node.get_logger().error(\"服务请求失败！%r\"%(e,))",
				"    else:",
				"        my_node.get_logger().info('响应结果：')",
				"    ",
				"    # 5.释放资源。",
				"    rclpy.shutdown()",
"",
"",
				"if __name__ == '__main__':",
				"    main()",
		],
		"description": "创建服务通讯客户端代码模板"
	},

	"ros2创建服务通讯服务端py": {
		"prefix": "ros2_service_service_py",
		"body": [
				"\"\"\"",
				"    需求：编写服务端，接收客户端发送请求，处理数据后将结果响应回客户端。",
				"    步骤：",
				"        1.导包；",
				"        2.初始化 ROS2 客户端；",
				"        3.定义节点类；",
				"            3-1.创建服务端；",
				"            3-2.处理请求数据并响应结果。",
				"        4.调用spin函数，并传入节点对象；",
				"        5.释放资源。",
"",
				"需要修改的变量名：",
				"    MyInterfacePkg      自定义的接口包名称",
				"    MySrvType           .srv的名称",
				"    Mynode              节点名称",
				"    globle_log_py     全局日志名",
"",
				"需要自定义的地方：",
				"    def send_request(self):          请求输入需要自定义",
"",
				"\"\"\"",
				"# 1.导包；",
				"import rclpy",
				"from rclpy.node import Node",
				"from MyInterfacePkg.srv import MySrvType ",
"",
				"# 3.定义节点类；",
				"class MySrvType (Node):",
"",
				"    def __init__(self):",
				"        super().__init__('MySrvType')",
				"        self.service=self.create_service(MySrvType ,\"MySrvType\",self.add_callback)",
				"        self.get_logger().info(\"服务端启动！\")",
"",
"",
				"    # 3-3.组织消息并发布。request对应.srv文件第一部分，response对应第二部分",
				"    def add_callback(self,request,response):",
				"        self.get_logger().info('请求数据:( \"%\",\"%d\",\"%d\"),响应结果：(sum,average)=(\"%d\",\"%d\")' % (1,2,3,4,5))",
				"        return response",
"",
				"def main(args=None):",
				"    # 2.初始化 ROS2 客户端；",
				"    rclpy.init(args=args)",
				"    # 4.调用spin函数,并传入节点对象;",
				"    my_node = MySrvType ()",
				"    rclpy.spin(my_node)",
				"    # 5.释放资源。",
				"    rclpy.shutdown()",
"",
"",
				"if __name__ == '__main__':",
				"    main()",
		],
		"description": "创建服务通讯服务端代码模板"
	},

	"ros2动作通讯服务端py": {
		"prefix": "ros2_action_service_py",
		"body": [
				"\"\"\"  ",
				"    需求：编写动作服务端实现，可以提取客户端请求提交的数据，并且处理数据，",
				"        每进行一步都计算当前运算进度并连续反馈回客户端，最后，在将最终结果返回给客户端。",
				"    步骤：",
				"        1.导包；",
				"        2.初始化 ROS2 客户端；",
				"        3.定义节点类；",
				"            3-1.创建动作服务端；",
				"            3-2.生成连续反馈；",
				"            3-3.生成最终响应。",
				"        4.调用spin函数，并传入节点对象；",
				"        5.释放资源。",
"",
				"    需要修改的变量名：    ",
				"        MyInterfacePkg      自定义的接口包名称",
				"        MyActionType        .action的名称",
				"        Mynode              自定义节点名称",
"",
				"\"\"\"",
"",
				"# 1.导包；",
				"import time",
				"import rclpy",
				"from rclpy.action import ActionServer",
				"from rclpy.action import GoalResponse",
				"from rclpy.action import CancelResponse",
				"from rclpy.node import Node",
"",
				"from MyInterfacePkg.action import MyActionType",
"",
				"# 3.定义节点类；",
				"class Mynode(Node):",
"",
				"    def __init__(self):",
				"        super().__init__('Mynode')",
				"        # 3-1.创建动作服务端；",
				"        \"\"\"  self,node,action_type,action_name,execute_callback\"\"\"",
				"        self._action_server = ActionServer(",
				"            self,",
				"            MyActionType,",
				"            'MyActionType',",
				"            execute_callback=self.execute_callback,",
				"            handle_accepted_callback=self.accepted_callback",
				"        )",
				"        self._action_server.register_goal_callback(self.goal_callback)",
				"        self._action_server.register_cancel_callback(self.cancel_callback)",
				"        self.get_logger().info('动作服务已经启动！')",
"",
"",
				"    def execute_callback(self, goal_handle):",
				"        self.get_logger().info('开始执行任务....')",
"",
				"        # 3-2.生成连续反馈；",
				"        feedback_msg = MyActionType.Feedback()",
"",
				"        sum = 0",
				"        for i in range(1, goal_handle.request.num + 1):",
				"            # 检查取消请求",
				"            if goal_handle.is_cancel_requested:",
				"                goal_handle.canceled()",
				"                self.get_logger().info('任务已取消')",
				"                return MyActionType.Result(sum)  # 返回取消结果",
				"            ",
				"            sum += i",
				"            feedback_msg.MyActionType = i / goal_handle.request.num",
				"            self.get_logger().info('连续反馈: %.2f' % feedback_msg.MyActionType)",
				"            goal_handle.publish_feedback(feedback_msg)",
				"            time.sleep(0.5)",
"",
				"        # 3-3.生成最终响应。",
				"        goal_handle.succeed()",
				"        result = MyActionType.Result()",
				"        result.sum = sum",
				"        self.get_logger().info('任务完成！')",
"",
				"        return result",
				"    ",
				"    #接受请求的接受逻辑",
				"    def goal_callback(self,goal_request):",
				"        #编写请求回应逻辑",
				"        if(goal_request.num<1):",
				"            self.get_logger().info('请输入正确的输入数据！')",
				"            return GoalResponse.REJECT",
				"        else:",
				"            self.get_logger().info('已收到请求！')",
				"            return GoalResponse.ACCEPT",
				"        ",
				"    #连续反馈逻辑",
				"    def accepted_callback(self,goal_handle):",
				"        self.get_logger().info('调用accepted_callback')",
				"        goal_handle.execute()#会去调用self.execute_callback",
"",
				"    #编写任务取消反馈,未成功,未知原因",
				"    def cancel_callback(self,cancel_request):",
				"        self.get_logger().info(cancel_request.__str__())",
				"        self.get_logger().info('任务取消！')",
				"        return CancelResponse.ACCEPT",
"",
				"def main(args=None):",
"",
				"    # 2.初始化 ROS2 客户端；",
				"    rclpy.init(args=args)",
"",
				"    # 4.调用spin函数，并传入节点对象；",
				"    action_server = Mynode()",
				"    rclpy.spin(action_server)",
"",
				"    # 5.释放资源。",
				"    rclpy.shutdown()",
"",
				"if __name__ == '__main__':",
				"    main()",
		],
		"description": "创建动作通讯服务端py模板"
	},

	"ros2动作通讯客户端py": {
		"prefix": "ros2_action_service_py",
		"body": [
					"\"\"\"  ",
					"需求：编写动作客户端实现，可以提交一个整型数据到服务端，并处理服务端的连续反馈以及最终返回结果。",
					"步骤：",
					"    1.导包；",
					"    2.初始化 ROS2 客户端；",
					"    3.定义节点类；",
					"        3-1.创建动作客户端；",
					"        3-2.发送请求；",
					"        3-3.处理目标发送后的反馈；",
					"        3-4.处理连续反馈；",
					"        3-5.处理最终响应。",
					"    4.调用spin函数，并传入节点对象；",
					"    5.释放资源。 ",
"",
				"    需要修改的变量名：    ",
				"        MyInterfacePkg      自定义的接口包名称",
				"        MyActionType        .action的名称",
				"        Mynode              自定义节点名称",
"",
					"\"\"\"",
					"# 1.导包；",
					"import sys",
					"import rclpy",
					"from rclpy.action import ActionClient",
					"from rclpy.node import Node",
					"from rclpy.logging import get_logger",
					"from MyInterfacePkg.action import MyActionType",
"",
					"# 3.定义节点类；",
					"class Mynode(Node):",
"",
					"    def __init__(self):",
					"        super().__init__('Mynode')",
					"        # 3-1.创建动作客户端；",
					"        \"\"\"node,action_type,action_name\"\"\"",
					"        self._action_client = ActionClient(self, MyActionType, 'MyActionType')",
"",
					"    def send_goal(self, num):",
					"        # 3-2.发送请求；",
					"        goal_msg = MyActionType.Goal()",
					"        goal_msg.num = num",
					"        self._action_client.wait_for_server()",
					"        \"\"\" self, goal, feedback_callback \"\"\"",
					"        self._send_goal_future = self._action_client.send_goal_async(goal_msg, feedback_callback=self.feedback_callback)",
					"        self._send_goal_future.add_done_callback(self.goal_response_callback)",
					"    ",
					"    # 3-4.处理连续反馈；",
					"    def feedback_callback(self, feedback_msg):",
					"        feedback = (int)(feedback_msg.feedback.MyActionType * 100)",
					"        self.get_logger().info('当前进度: %d%%' % feedback)",
"",
					"    # 3-3.处理目标发送后的反馈；",
					"    def goal_response_callback(self, future):",
					"        goal_handle = future.result()",
					"        if not goal_handle.accepted:",
					"            self.get_logger().info('请求被拒绝')",
					"            return",
"",
					"        self.get_logger().info('请求被接收，开始执行任务！')",
"",
					"        self._get_result_future = goal_handle.get_result_async()",
					"        self._get_result_future.add_done_callback(self.get_result_callback)",
"",
					"    # 3-5.处理最终响应。",
					"    def get_result_callback(self, future):",
					"        result = future.result().result",
					"        self.get_logger().info('最终计算结果：sum = %d' % result.sum)",
					"        # 5.释放资源。",
					"        rclpy.shutdown()",
"",
"",
					"def main(args=None):",
"",
					"    if len(sys.argv)!=2:",
					"        get_logger('globle_log_name').error('请输入正确的命令行参数！')",
					"        return",
					"    ",
					"    # 2.初始化 ROS2 客户端；",
					"    rclpy.init(args=args)",
					"    # 4.调用spin函数，并传入节点对象；",
"",
					"    action_client = Mynode()",
					"    action_client.send_goal(int(sys.argv[1]))",
					"    rclpy.spin(action_client)",
					"    ",
					"    rclpy.shutdown()",
"",
					"if __name__ == '__main__':",
					"    main()",
		],
		"description": "创建动作通讯客户端模板"
	},

	"ros2参数服务服务端py": {
		"prefix": "ros2_param_service_py",
		"body": [
				"\"\"\"",
				"    需求：编写参数服务端，设置并操作参数。",
				"    步骤：",
				"        1.导包；",
				"        2.初始化 ROS2 客户端；",
				"        3.定义节点类；",
				"            3-1.声明参数；",
				"            3-2.查询参数；",
				"            3-3.修改参数；",
				"            3-4.删除参数。",
				"        4.创建节点对象，调用参数操作函数，并传递给spin函数；",
				"        5.释放资源。",
				"    需要修改的变量名：",
				"        Mynode              节点名称",
				"\"\"\"",
				"# 1.导包；",
				"import rclpy",
				"from rclpy.node import Node",
"",
				"# 3.定义节点类；",
				"class Mynode(Node):",
				"    def __init__(self):",
				"        super().__init__(\"Mynode_param\",allow_undeclared_parameters=True)",
				"        self.get_logger().info(\"参数演示\")",
"",
				"    # 3-1.声明参数；",
				"    def declare_param(self):",
				"        self.get_logger().info(\"声明参数！\")",
				"        #API",
				"        #self.declare_parameter(\"key\",value)",
				"        #self.p1 = rclpy.Parameter(\"key1\",value=value1)",
				"        #self.set_parameters([self.p1,...,self.pn])",
"",
				"    # 3-2.查询参数；",
				"    def get_param(self):",
				"        self.get_logger().info(\"--------------查-------------\")",
				"        #API",
				"        #self.has_parameter(\"key\")                              #返回bool",
				"        #param = self.get_parameter(\"key\")                      #返回Parameter",
				"        #params = self.get_parameters([\"key1\",\"key2\",\"key3\"])   #List[str] -> List[Parameter]",
"",
				"    # 3-3.修改参数；",
				"    def update_param(self):",
				"        self.get_logger().info(\"--------------改-------------\")",
				"        #API",
				"        #self.set_parameters(parameter_list: List[Parameter]) -> List[SetParametersResult]",
				"        #self.set_parameters([rclpy.Parameter(\"key1\",value = v1),....,rclpy.Parameter(\"keyn\",value = vn)])",
"",
				"    # 3-4.删除参数。",
				"    def del_param(self):",
				"        self.get_logger().info(\"--------------删-------------\")",
				"        #API",
				"        #self.undeclare_parameter(name: str) -> None  #可以删除self.declare_parameter声明的参数",
"",
"",
				"def main():",
				"    # 2.初始化 ROS2 客户端；",
				"    rclpy.init()",
"",
				"    # 4.创建节点对象，调用参数操作函数，并传递给spin函数；",
				"    param_server = Mynode()",
				"    param_server.declare_param()",
				"    param_server.get_param()",
				"    param_server.update_param()",
				"    param_server.del_param()",
"",
				"    rclpy.spin(param_server)",
				"    # 5.释放资源。",
				"    rclpy.shutdown()",
"",
				"if __name__ == \"__main__\":",
				"    main()",
		],
		"description": "参数服务服务端py模板"
	},

	"ros2参数服务客户端py": {
		"prefix": "ros2_param_client_py",
		"body": [
				"\"\"\"",
"",
				"    需求：编写参数客户端，获取或修改服务端参数。",
				"    步骤：",
				"        1.导包；",
				"        2.初始化 ROS2 客户端；",
				"        3.定义节点类；",
				"            3-1.查询参数；",
				"            3-2.修改参数；",
				"        4.释放资源。",
				"    需求：编写参数客户端，访问并修改参数。",
				"    需要修改的变量名：",
				"        Mynode      自定义节点名称",
				"        Node_param  参数服务通讯服务名称，与客户端一致",
				"\"\"\"",
"",
				"import rclpy",
				"from rclpy.node import Node",
				"from rcl_interfaces.srv import ListParameters, GetParameters, SetParameters",
				"from rcl_interfaces.msg import Parameter, ParameterValue, ParameterType",
"",
				"class Mynode(Node):",
				"    \"\"\"ROS2参数客户端，用于查询和修改服务端参数\"\"\"",
				"    ",
				"    def __init__(self, node_name=\"Mynode\"):",
				"        super().__init__(node_name)",
				"        # 初始化服务客户端",
				"        self._init_clients(\"Node_param\")",
				"        ",
				"    def _init_clients(self,param_node_name):",
				"        \"\"\"初始化所有服务客户端\"\"\"",
				"        self.list_client = self.create_client(",
				"            ListParameters, '/'+param_node_name+'/list_parameters')",
				"        self.get_client = self.create_client(",
				"            GetParameters, '/'+param_node_name+'/get_parameters')",
				"        self.set_client = self.create_client(",
				"            SetParameters, '/'+param_node_name+'/set_parameters')",
				"        ",
				"        # 等待服务连接",
				"        self._wait_for_services()",
				"    ",
				"    def _wait_for_services(self):",
				"        \"\"\"等待所有服务可用\"\"\"",
				"        services = [",
				"            (self.list_client, \"ListParameters\"),",
				"            (self.get_client, \"GetParameters\"), ",
				"            (self.set_client, \"SetParameters\")",
				"        ]",
				"        ",
				"        for client, name in services:",
				"            while not client.wait_for_service(timeout_sec=1.0):",
				"                self.get_logger().info(f'等待 {name} 服务连接...')",
				"    ",
				"    def list_parameters(self) -> list:",
				"        \"\"\"获取参数列表\"\"\"",
				"        req = ListParameters.Request()",
				"        future = self.list_client.call_async(req)",
				"        rclpy.spin_until_future_complete(self, future)",
				"        return future.result().result.names",
				"    ",
				"    def get_parameters(self, names: list) -> dict:",
				"        \"\"\"获取指定参数值\"\"\"",
				"        req = GetParameters.Request()",
				"        req.names = names",
				"        future = self.get_client.call_async(req)",
				"        rclpy.spin_until_future_complete(self, future)",
				"        ",
				"        result = {}",
				"        response = future.result()",
				"        for name, value in zip(names, response.values):",
				"            if value.type == ParameterType.PARAMETER_STRING:",
				"                result[name] = value.string_value",
				"            elif value.type == ParameterType.PARAMETER_DOUBLE:",
				"                result[name] = value.double_value",
				"            # 可以添加其他类型的处理",
				"        return result",
				"    ",
				"    def set_parameters(self, parameters: dict) -> bool:",
				"        \"\"\"设置参数值\"\"\"",
				"        req = SetParameters.Request()",
				"        param_list = []",
				"        ",
				"        for name, value in parameters.items():",
				"            param = Parameter()",
				"            param.name = name",
				"            ",
				"            if isinstance(value, str):",
				"                param.value = ParameterValue(",
				"                    type=ParameterType.PARAMETER_STRING,",
				"                    string_value=value",
				"                )",
				"            elif isinstance(value, float):",
				"                param.value = ParameterValue(",
				"                    type=ParameterType.PARAMETER_DOUBLE,",
				"                    double_value=value",
				"                )",
				"            # 可以添加其他类型的处理",
				"                ",
				"            param_list.append(param)",
				"        ",
				"        req.parameters = param_list",
				"        future = self.set_client.call_async(req)",
				"        rclpy.spin_until_future_complete(self, future)",
				"        ",
				"        # 检查所有参数是否设置成功",
				"        return all(r.successful for r in future.result().results)",
"",
				"def main():",
				"    rclpy.init()",
				"    ",
				"    try:",
				"        client = Mynode()",
				"        ",
				"        # 获取参数列表",
				"        client.get_logger().info(\"\n--------- 参数列表 ---------\")",
				"        param_names = client.list_parameters()",
				"        for name in param_names:",
				"            client.get_logger().info(f\"• {name}\")",
				"        ",
				"        # 获取参数值",
				"        client.get_logger().info(\"\n--------- 参数详情 ---------\")",
				"        params_to_get = [\"height\", \"car_type\"]",
				"        param_values = client.get_parameters(params_to_get)",
				"        ",
				"        for name, value in param_values.items():",
				"            if isinstance(value, str):",
				"                client.get_logger().info(f\"{name}: {value} (字符串)\")",
				"            elif isinstance(value, float):",
				"                client.get_logger().info(f\"{name}: {value:.2f} (浮点数)\")",
				"        ",
				"        # 设置参数",
				"        client.get_logger().info(\"\n--------- 设置参数 ---------\")",
				"        params_to_set = {",
				"            \"car_type\": \"Pig\",",
				"            \"height\": 0.3",
				"        }",
				"        ",
				"        success = client.set_parameters(params_to_set)",
				"        if success:",
				"            client.get_logger().info(\"所有参数设置成功\")",
				"        else:",
				"            client.get_logger().warn(\"部分参数设置失败\")",
				"            ",
				"    finally:",
				"        rclpy.shutdown()",
"",
				"if __name__ == \"__main__\":",
				"    main()",
		],
		"description": "参数服务客户端py模板"
	},

	"ros2 launch文件配置": {
		"prefix": "ros2_launch_py",
		"body": [
				"#至少需要包含以下两个包",
				"from launch import LaunchDescription",
				"from launch_ros.actions import Node",
				"#用于调用指令",
				"from launch.actions import ExecuteProcess",
				"#用于创建事件注册对象",
				"from launch.actions import LogInfo, RegisterEventHandler",
				"from launch.event_handlers import OnProcessExit, OnProcessStart",
				"#在launch文件启动时动态地设置param参数值",
				"from launch.actions import DeclareLaunchArgument",
				"from launch.substitutions import LaunchConfiguration",
				"#用于设置相对路径，查找share目录下对应的包",
				"import os.path",
				"from ament_index_python.packages import get_package_share_directory",
				"#在当前launch文件中包含其他launch文件",
				"from launch.actions import IncludeLaunchDescription",
				"from launch.launch_description_sources import PythonLaunchDescriptionSource",
				"#用于将多个节点分组",
				"from launch.actions import GroupAction",
				"from launch_ros.actions import PushRosNamespace",
"",
"",
				"def generate_launch_description():",
				"    #启动多个节点，设置启动配置",
				"    t1 = Node(package=\"turtlesim\", executable=\"turtlesim_node\")",
				"    t2 = Node(package=\"turtlesim\", executable=\"turtlesim_node\", namespace=\"t2\")",
"",
				"    return LaunchDescription([t1,t2])",
"",
"",
				"#以下是使用实例",
				"def launch_nodes():",
				"    # 1.launch重命名，防止重名",
				"    \"\"\"",
				"    构造函数参数说明：",
				"        - package 被执行的程序所属的功能包",
				"        - executable 可执行程序",
				"        - name 节点名称",
				"        - namespace 设置命名空间",
				"        - exec_name 设置程序标签",
				"        - parameters 设置参数",
				"        - remappings 实现话题重映射",
				"        - ros_arguments 为节点传参",
				"        - arguments 为节点传参",
				"        - respawn 是否自动重启",
"",
				"    package名称不会出现在节点名里",
				"    executable节点构造函数代码定义节点时的名称就是节点名，可以被name修改代码定义的节点名，代码还可以定义命名空间，即节点名的上一级名称",
				"    namespace可以修改节点构造函数代码定义的命名空间",
				"    remappings修改的对象是节点下的四种通讯机制对应的话题、服务的全名，是在构造函数代码里定义的",
				"    其全名分为全局、相对、私有，分别是/话题、服务名、/节点的命名空间/话题、服务名、/节点的命名空间/节点名/话题、服务名。\"\"\"",
"",
				"    turtle1 = Node(",
				"        package=\"turtlesim\",",
				"        executable=\"turtlesim_node\",",
				"        exec_name=\"my_label\",",
				"        ros_arguments=[\"--remap\", \"__ns:=/t2\"],",
				"        # ros2 run turtlesim turtlesim_node --ros-args --remap __ns:=/t2",
				"        namespace=\"t2\",",
				"        remappings=[(\"/turtle1/cmd_vel\",\"/cmd_vel\")],",
				"        respawn=True",
				"    )",
"",
				"    turtle2 = Node(",
				"        package=\"turtlesim\",",
				"        executable=\"turtlesim_node\",",
				"        name=\"haha\",",
				"        # 方式1：直接设置",
				"        # parameters=[{\"background_r\": 255, \"background_g\": 0, \"background_b\": 125}],",
				"        # 方式2：读取yaml文件",
				"        # parameters=[\"./install/cpp01_launch/share/cpp01_launch/config/haha.yaml\"],",
				"        parameters=[",
				"            os.path.join(",
				"                get_package_share_directory(\"cpp01_launch\"), \"config\", \"haha.yaml\"",
				"            )",
				"        ]",
				"    )",
				"    node_list = [turtle1, turtle2]",
				"    return node_list",
"",
"",
				"def launch_cmd(script):",
				"    exe_process = ExecuteProcess(",
				"        cmd=[",
				"            script",
				"        ],",
				"        output=\"both\",",
				"        shell=True,",
				"    )",
				"    return exe_process",
"",
"",
				"def launch_with_args():",
				"    # 1.声明参数（变量）",
				"    bg_r = DeclareLaunchArgument(\"back_r\", default_value=\"255\")",
				"    # 2.调用参数（变量）",
				"    turtle = Node(",
				"        package=\"turtlesim\",",
				"        executable=\"turtlesim_node\",",
				"        parameters=[{\"background_r\": LaunchConfiguration(\"back_r\")}],",
				"    )",
				"    node_list = [bg_r, turtle]",
				"    return node_list",
"",
				"def launch_with_event():",
"",
				"    turtle = Node(package=\"turtlesim\", executable=\"turtlesim_node\")",
"",
				"    spawn = ExecuteProcess(",
				"        cmd=[\"ros2 service call /spawn turtlesim/srv/Spawn \\\"{'x': 8.0, 'y':3.0}\\\"\"],",
				"        output=\"both\",",
				"        shell=True,",
				"    )",
"",
				"    # 创建handler",
				"    # 类型是在目标程序target_action执行结束后执行on_exit程序,还有其他类型：OnProcessStart,OnShutdown,OnExecutionComplete等",
				"    start_evt_hdl = OnProcessStart(target_action=turtle, on_start=spawn)",
"",
				"    exit_evt_hdl = OnProcessExit(",
				"        target_action=turtle, on_exit=LogInfo(msg=\"turtlesim_node 已退出\")",
				"    )",
"",
				"    # 注册事件",
				"    event_start = RegisterEventHandler(start_evt_hdl)",
				"    event_exit = RegisterEventHandler(exit_evt_hdl)",
"",
				"    return [turtle,event_start,event_exit]",
"",
				"def launch_include():",
				"    other_launch_path = os.path.join(",
				"    get_package_share_directory(\"cpp01_launch\"),",
				"    \"launch/py\",",
				"    \"py04_args_launch.py\")",
"",
				"    include = IncludeLaunchDescription(",
				"        launch_description_source=PythonLaunchDescriptionSource(other_launch_path),",
				"        launch_arguments=[(\"back_r\", \"0\")],",
				"    )",
				"    return include",
"",
				"def launch_group():",
				"    # 创建3个节点",
				"    t1 = Node(package=\"turtlesim\", executable=\"turtlesim_node\", name=\"t1\")",
				"    t2 = Node(package=\"turtlesim\", executable=\"turtlesim_node\", name=\"t2\")",
				"    t3 = Node(package=\"turtlesim\", executable=\"turtlesim_node\", name=\"t3\")",
"",
				"    # 分组",
				"    group1 = GroupAction([PushRosNamespace(\"g1\"), t1, t2])  # 设置当前组命名空间，以及包含的节点",
				"    group2 = GroupAction([PushRosNamespace(\"g2\"), t3])",
"",
				"    node_list = [group1, group2]",
"",
				"    return node_list",
		],
		"description": "配置luanch文件示例"
	}

	// "Print to console": {
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
}